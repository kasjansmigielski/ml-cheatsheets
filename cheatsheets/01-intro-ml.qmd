---
title: "Wprowadzenie do Machine Learning â€” fundament"
format:
  html:
    code-tools: true
---

## ğŸ¤– Czym jest Machine Learning?

**Machine Learning (ML)** to dziedzina informatyki, ktÃ³ra pozwala komputerom **uczyÄ‡ siÄ™ i podejmowaÄ‡ decyzje na podstawie danych**, bez koniecznoÅ›ci programowania kaÅ¼dej reguÅ‚y z gÃ³ry.

::: {.callout-note}
## ğŸ’¡ Intuicja
Zamiast pisaÄ‡ kod "jeÅ›li temperatura > 25Â°C, to bÄ™dzie sÅ‚onecznie", **ML pozwala algorytmowi samemu odkryÄ‡** te zaleÅ¼noÅ›ci z historycznych danych pogodowych.
:::

---

## ğŸ“Š GÅ‚Ã³wne rodzaje ML

### 1) **Supervised Learning** (Uczenie nadzorowane)
**Mamy dane + znamy prawidÅ‚owe odpowiedzi**

```{python}
#| label: supervised-example
#| warning: false

# PrzykÅ‚ad: predykcja ceny domu
# Dane wejÅ›ciowe: powierzchnia, lokalizacja, rok budowy
# Cel: przewidzieÄ‡ cenÄ™

import pandas as pd
from sklearn.linear_model import LinearRegression

# PrzykÅ‚adowe dane
data = pd.DataFrame({
    'powierzchnia': [50, 75, 100, 120, 150],
    'rok_budowy': [1990, 2000, 2010, 2015, 2020],
    'cena': [300000, 400000, 550000, 650000, 800000]  # znamy prawdziwe ceny!
})

print("Dane treningowe:")
print(data)

# Trenowanie modelu
model = LinearRegression()
X = data[['powierzchnia', 'rok_budowy']]
y = data['cena']
model.fit(X, y)

# Predykcja dla nowego domu
nowy_dom = [[90, 2005]]
przewidywana_cena = model.predict(nowy_dom)
print(f"\nPredykcja dla domu 90mÂ², rok 2005:")
print(f"Przewidywana cena: {przewidywana_cena[0]:.0f} zÅ‚")
```

**Real-world zastosowania:**
- Predykcja cen akcji/nieruchomoÅ›ci
- Diagnoza medyczna (klasyfikacja chorÃ³b)
- Filtrowanie spamu w emailach
- Rozpoznawanie mowy/obrazÃ³w

---

### 2) **Unsupervised Learning** (Uczenie nienadzorowane)  
**Mamy tylko dane, szukamy ukrytych wzorcÃ³w**

```{python}
#| label: unsupervised-example
#| warning: false

# PrzykÅ‚ad: segmentacja klientÃ³w sklepu
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Dane klientÃ³w: wiek i wydatki miesiÄ™czne
klienci = pd.DataFrame({
    'wiek': [25, 30, 35, 22, 28, 45, 50, 55, 60, 65],
    'wydatki': [2000, 2500, 3000, 1800, 2200, 4000, 4500, 3500, 3000, 2800]
})

print("Dane klientÃ³w:")
print(klienci.head())

# Grupowanie klientÃ³w w 3 segmenty
kmeans = KMeans(n_clusters=3, random_state=42)
klienci['segment'] = kmeans.fit_predict(klienci[['wiek', 'wydatki']])

print("\nSegmenty klientÃ³w:")
for i in range(3):
    segment = klienci[klienci['segment'] == i]
    print(f"Segment {i}: Å›redni wiek {segment['wiek'].mean():.0f}, "
          f"Å›rednie wydatki {segment['wydatki'].mean():.0f}")

print(f"\nPrzykÅ‚ad: klient 30 lat, wydaje 2500zÅ‚ -> segment {kmeans.predict([[30, 2500]])[0]}")
```

**Real-world zastosowania:**
- Segmentacja klientÃ³w (marketing)
- Wykrywanie anomalii (cyberbezpieczeÅ„stwo)
- Analiza koszykowa (co kupujÄ… razem)
- Kompresja danych

---

### 3) **Reinforcement Learning** (Uczenie ze wzmocnieniem)
**Agent uczy siÄ™ przez interakcjÄ™ i nagrody/kary**

```{python}
#| label: reinforcement-example
#| warning: false

# PrzykÅ‚ad koncepcyjny: optymalizacja reklam
class SimpleAgent:
    def __init__(self):
        # Jakie reklamy pokazywaÄ‡: ["sportowe", "technologiczne", "modowe"]
        self.ad_types = ["sportowe", "technologiczne", "modowe"]
        self.rewards = [0, 0, 0]  # nagrody za kaÅ¼dy typ
        self.counts = [0, 0, 0]   # ile razy pokazane
    
    def choose_ad(self):
        # Wybierz reklamÄ™ z najwyÅ¼szÄ… Å›redniÄ… nagrodÄ…
        avg_rewards = [r/max(c,1) for r, c in zip(self.rewards, self.counts)]
        return avg_rewards.index(max(avg_rewards))
    
    def update_reward(self, ad_type, clicked):
        # Aktualizuj nagrody na podstawie klikniÄ™Ä‡
        self.counts[ad_type] += 1
        if clicked:
            self.rewards[ad_type] += 1
    
    def get_stats(self):
        for i, ad_type in enumerate(self.ad_types):
            rate = self.rewards[i] / max(self.counts[i], 1) * 100
            print(f"{ad_type}: {self.counts[i]} pokazaÅ„, {self.rewards[i]} klikniÄ™Ä‡ ({rate:.1f}%)")

# Symulacja
import numpy as np
np.random.seed(42)

agent = SimpleAgent()
print("ğŸ¯ Symulacja optymalizacji reklam:")
print("Agent uczy siÄ™, ktÃ³re reklamy dziaÅ‚ajÄ… najlepiej...\n")

for day in range(10):
    ad = agent.choose_ad()
    # RÃ³Å¼ne prawdopodobieÅ„stwa klikniÄ™Ä‡ dla rÃ³Å¼nych typÃ³w reklam
    click_probs = [0.1, 0.3, 0.2]  # technologiczne najlepsze
    clicked = np.random.random() < click_probs[ad]
    agent.update_reward(ad, clicked)
    print(f"DzieÅ„ {day+1}: pokazano {agent.ad_types[ad]}, klikniÄ™ta: {clicked}")

print("\nğŸ“Š KoÅ„cowe statystyki:")
agent.get_stats()
```

**Real-world zastosowania:**
- Gry komputerowe (AI graczy)
- Autonomiczne pojazdy
- Optymalizacja reklam online
- Roboty przemysÅ‚owe

---

## ğŸ¯ Jak wybraÄ‡ odpowiedni typ ML?

| **Sytuacja** | **Typ ML** | **PrzykÅ‚ad** |
|-------------|------------|--------------|
| Masz dane z prawidÅ‚owymi odpowiedziami | **Supervised** | Spam/nie-spam w emailach |
| Chcesz znaleÅºÄ‡ ukryte grupÑ‹ | **Unsupervised** | Segmentacja klientÃ³w |
| System ma siÄ™ uczyÄ‡ przez trial & error | **Reinforcement** | Bot do gier |

---

## ğŸ”§ Podstawowe kroki projektu ML

```{python}
#| label: ml-workflow-example
#| warning: false

# Kompletny workflow ML na przykÅ‚adzie klasyfikacji iris
import pandas as pd
import numpy as np
from sklearn.datasets import load_iris
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report

print("ğŸ”¬ Kompletny workflow projektu ML")
print("=" * 40)

# 1. ZaÅ‚aduj i poznaj dane
iris = load_iris()
data = pd.DataFrame(iris.data, columns=iris.feature_names)
data['target'] = iris.target
target_names = iris.target_names

print("1ï¸âƒ£ Dane zaÅ‚adowane:")
print(f"KsztaÅ‚t: {data.shape}")
print(f"Klasy: {target_names}")
print(data.head(3))

# 2. Przygotuj dane (czyszczenie, encoding)
X = data.drop('target', axis=1)
y = data['target']

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
print(f"\n2ï¸âƒ£ Dane przeskalowane (pierwsze 3 cechy pierwszej prÃ³bki):")
print(f"Przed: {X.iloc[0, :3].values}")
print(f"Po: {X_scaled[0, :3]}")

# 3. Podziel na train/test
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)
print(f"\n3ï¸âƒ£ PodziaÅ‚ danych:")
print(f"Train: {len(X_train)} prÃ³bek")
print(f"Test: {len(X_test)} prÃ³bek")

# 4. Wybierz i wytrenuj model
model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)
print(f"\n4ï¸âƒ£ Model wytrenowany: RandomForestClassifier")

# 5. OceÅ„ wyniki
predictions = model.predict(X_test)
accuracy = accuracy_score(y_test, predictions)
print(f"\n5ï¸âƒ£ Wyniki:")
print(f"DokÅ‚adnoÅ›Ä‡: {accuracy:.2%}")

# PrzykÅ‚ad predykcji
sample_flower = X_test[0:1]
predicted_class = model.predict(sample_flower)[0]
predicted_name = target_names[predicted_class]
actual_name = target_names[y_test.iloc[0]]
print(f"\nPrzykÅ‚ad predykcji:")
print(f"Przewidywana klasa: {predicted_name}")
print(f"Rzeczywista klasa: {actual_name}")
print("âœ… Poprawnie!" if predicted_name == actual_name else "âŒ BÅ‚Ä…d")
```

---

## ğŸ’¡ NajwaÅ¼niejsze biblioteki Python dla ML

```python
# Podstawowe przetwarzanie danych
import pandas as pd      # DataFrames, CSV, analiza
import numpy as np       # obliczenia numeryczne

# Machine Learning
from sklearn import *    # algorytmy ML, preprocessing, metryki
import xgboost as xgb   # zaawansowane drzewa decyzyjne

# Wizualizacja
import matplotlib.pyplot as plt  # wykresy
import seaborn as sns           # piÄ™kne wykresy statystyczne

# Deep Learning
import tensorflow as tf  # sieci neuronowe (Google)
import torch            # sieci neuronowe (Facebook)
```

---

::: {.callout-tip}
## ğŸ¯ Pro tips dla poczÄ…tkujÄ…cych

1. **Zacznij od prostych algorytmÃ³w** - Linear Regression, Decision Trees
2. **80% czasu to przygotowanie danych** - czyszczenie, eksploracja, feature engineering
3. **Zawsze sprawdÅº czy model nie jest overfitted** - uÅ¼yj validation set
4. **Rozumiej swoje dane** przed wyborem algorytmu
5. **Praktyka > teoria** - rÃ³b duÅ¼o projektÃ³w na rÃ³Å¼nych danych!
:::

**NastÄ™pna Å›ciÄ…gawka:** [Linear Regression w praktyce](02-linear-regression.qmd) ğŸš€
